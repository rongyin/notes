## 并发之锁

### 锁的状态
锁的状态，专门针对synchronized。
#### 无锁
无锁没有对资源进行锁定，所有的线程都可以访问 (read) 并修改 (write) 同一个资源，但同时只有一个线程对资源的修改能成功。
* 无锁的特定是修改操作在循环中进行，线程会不断尝试修改共享资源。如果没有冲突就修改成功并退出，否则继续循环尝试。
* 如果有多个线程修改同一个资源，必定会有一个线程修改成功，而其他尝试修改失败的线程会不断尝试，要么修改成功，要么尝试次数达到JVM的尝试次数上限后退出。
* CAS的应用是无锁的一种实现。无锁无法全面代替有锁，但在某些场合的性能较高。
#### 偏向锁 (Biased Locking)
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取所的代价。当一个线程访问同步代码块并获取锁时，会在对象头的标记字段 (Mark Word) 里存储锁偏向的线程id。在该线程进入和退出同步块时不再通过CAS操作加锁和解锁，而是通过检测标记字段里是否存有指向当前线程的偏向锁。
* 引入偏向锁是为了在无多线程竞争的情况下减少不必要的轻量锁执行路径，因为轻量锁的获取和释放依赖多次CAS原子指令，而偏向锁仅需在修改线程id时依赖一次CAS原子指令。
* 线程不会主动释放偏向锁，仅当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的释放，需要等待全局安全点，它会先暂停持有偏向锁的线程，判断锁对象是否处于被锁定状态。偏向锁被释放后恢复到无锁 (在标记字段的锁标志位为01) 或轻量级锁 (在标记字段的锁标志位为00) 的状态。
* 偏向锁在JDK6以后默认开启，可通过JVM参数关闭偏向锁，`-XX:UseBiasedLocking=false`。关闭之后程序默认进入轻量级锁状态。
#### 轻量级锁 (Lightweight Locking)
当前共享资源被持有偏向锁的线程持有，并被另外的线程访问时，偏向锁就会升级为轻量级锁。其他线程通过自旋的形式尝试获取锁，从而不会阻塞，提高性能。
#### 重量级锁 (Heavy Locking)
***

### LockSupport
用来创建锁和其他同步类的基本线程阻塞原语。此类以及每个使用它的线程与一个许可关联。如果许可可用，调用park方法时会立即返回。如果许可不可用，则调用park方法会导致阻塞，或者调用unpack方法使许可可用。
***

### ReentrantLock
***

### AbstractQueuedSynchronizer
****

### 关键字synchronized
#### synchronized方法
* synchronized修饰的实例方法是以实例本身作为锁。
* synchronized修饰的静态方法是以Class对象作为锁。
* 当某个线程获得对象锁（类对象锁）时，其他并发访问持有相同锁（同一个对象的对象锁）的方法将被阻塞。不持有锁或持有不同锁的方法不受影响。即获取锁的操作粒度是线程，而不是调用。
#### synchronized块
* synchronized块可以通过类名.class获得类对象的内部锁。
* synchronized块可以通过this来获得对象锁。
* synchronized块可以使用额外对象的锁实现额外的原子操作。但是这种锁不稳定，除非这个额外对象是不可变的对象或者额外对象的所有可修改方法都是同步的。
#### 内置锁和显示锁
显示锁ReentrantLock并不是一种替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。这些功能包括：可定时的，可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。
* 可定时的与可轮询的锁获取模式由tryLock方法实现。
* 可中断的锁获取由lockInterruptibly方法实现。
* 公平性通过ReentrantLock初始化时构造函数的参数定义。
* 在内置锁中，锁的获取与释放都是基于代码块的。使用显示锁，则可在更小的粒度上控制所得获取释放。
#### synchronized和ReentrantLock
* synchronized方法或块中不能中断另外一个正在等待 (已阻塞) 的线程，但是ReentranetLock可以通过lockInterruptibly方法实现。
* synchronized方法或块中无法通过轮循的方式获得锁，但是ReentranetLock可以通过tryLock方法实现。
* synchronized方法或块中仅有一个内部条件，但是ReentrantLock可以使用Condition实现多个条件变量。
***

### 条件对象 (Condition)
#### await方法
等待获得锁的线程和调用await方法的线程状态上存在本质的不同。一旦一个线程调用await方法，即进入条件等待集。当锁可用时条件等待集中的线程不能立即解除阻塞状态。相反，这个线程仍将处于阻塞状态，直到另外一个现在在同一个等待集上调用signalAll方法为止。
#### signalAll方法
调用signalAll不会立即激活另一个等待线程，它仅仅解除等待线程的阻塞，以便同一个等待集中的其他线程在当前线程退出同步方法后，通过竞争获得锁实现对对象的访问。
#### signal方法
随机解除等待集中的一个线程的阻塞状态，这比解除等待集中所有线程的阻塞状态更有效，但也更危险。如果随机选择的线程发现自己仍然不能运行，那么它将再次进入阻塞状态。随后如果没有其他线程再次调用signal方法，系统将一直处于阻塞 (死锁) 状态。
***

### Vector与Collections.synchronizedList的区别
* Vector使用对象的内部锁 (synchronize方法) 来锁实例。
* Collections工具类返回的同步容器都是使用客户端锁来实现互斥锁。
***
